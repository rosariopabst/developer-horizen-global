################
Before you start
################

| This tutorial offers Java developers all the needed information to build a complete blockchain application on the Horizen Sidechain system.

| Apart from Java competency, this tutorial assumes that the reader has a high-level understanding of how blockchain-based distributed software works.

So, concepts such as Transactions, UTXO's, Blocks, Validation, Confirmation, Consensus, Unique chain, and chain forks, Hash Function, Private/Public key, and Signing should be known and understood, as well as the concept of a network of nodes and node communication.

If the above words are new to you, you can start by exploring the Horizen Academy website's material (`link <https://academy.horizen.global/>`_). Also, the original whitepaper by Satoshi Nakamoto, "Bitcoin: A Peer-to-Peer Electronic Cash System" (`link <https://bitcoin.org/bitcoin.pdf>`_), can be a good starting point. Direct experience with an existing blockchain software is also a very useful prerequisite. For that, you can install the Horizen "zend" software from (`Github <https://github.com/HorizenOfficial/zen>`_), and explore its rpc command interface and "regtest" mode.

****************
Why a Sidechain?
****************

| The success of Bitcoin and of many of its successors, has led to the attempt to build more and more applications that do not require to trust a third party, not even the author of the software, to be confident that data is stored and processed according to what expected and declared. These distributed applications keep the same concept of an append-only ledger, that replaces the usual application database, that is stored and updated by the applications nodes, which also communicate to check and agree on the legitimacy of transactions, accept them and apply the relevant database updates. The success of this approach requires, among other things, that the overall system includes a robust logic to reward the app actors, so that a good enough amount of decentralization is maintained, such that any attempt of malicious behaviours bear an overwhelmingly anti-economical cost. Today, the only way to guarantee this day one, is to code the logic and data of a new application in the software that runs an existing, established blockchain supporting a traded coin. That way, the robustness of the blockchain extends to the new app, that can immediately make use of the availability of existing miners, nodes, and the coin itself.

| Unfortunately, the above approach bears a scalability challenge. Blockchain's already suffer from scalability issues in their limited ability to process large volumes of transaction/time, and to accommodate sustained transaction peaks, that restrict the possibility of integrating a large number of new applications. Besides, each application logic needs to be coded in the node software, that is run by each node participating in the blockchain validation process, and this also has an impact on scalability: the software cannot be changed and updated each time we want to add a new application, and cannot grow indefinitely.

| Several attempts have been made to address these limitations; perhaps the most relevant is the idea of equipping each blockchain node with a virtual machine able to run short programs written in a specific, ad-hoc software language, e.g. Ethereum. This approach solves partially the logic scalability issue, as you don’t need to change the node software each time you want to add a new application, but it brings no solution to the limited transaction throughput. Besides, the virtual machine approach typically limits the length and complexity of the application that can be supported.

| The Horizen ecosystem offers a solution to the need of implementing blockchain-based distributed and decentralized applications, with all the advantages of the availability of a token that is publicly tradable, and that can be used both to rewards blockchain actors, and to support the business needs of the application itself, while solving both the scalability issues identified above. The approach is detailed in the (`Zendoo whitepaper <https://www.horizen.global/assets/files/Horizen-Sidechain-Zendoo-A_zk-SNARK-Verifiable-Cross-Chain-Transfer-Protocol.pdf>`_); the Horizen main blockchain, “mainchain”, offers the ability to declare the existence of a sidechain, through a specific transaction, and then the possibility of sending and receiving ZEN’s (the Horizen token) to and from that sidechain. There is no need to change the mainchain software each time a developer wants to implement a new application: each application will run on its own, purpose-built blockchain (a “sidechain”). This set of features, now implemented in testnet, is called “Cross-Chain Transfer Protocol”, and is documented in chapter 4 of this tutorial. The Cross-Chain transfer protocol does not impose particular requirements on the sidechain architecture, as long as it supports the sidechain side of the ZEN exchange protocol.

| The Horizen Sidechain SDK, offers all the basic components to build a sidechain that fully supports communication with the Horizen Mainchain. This codebase implements not only the Cross-Chain Transfer Protocol, but it also includes all the other elements needed to run a blockchain; in particular, it ships with a Proof of Stake consensus, that offers yet another scalability advantage, this time connected to the power and environmental cost of traditional Proof of Work consensus: we can scale the application logic, we can scale the number of transactions, without a big increase of wasted electricity. The architectural and protocol choices implemented by the SDK are introduced in the Zendoo whitepaper, as the “Latus” construction.
To facilitate the sidechain developers’ work, the Horizen Sidechain SDK includes an example of a Sidechain Application, “SimpleApp”, that just puts together all the standard components provided by the SDK, to run a basic sidechain able to receive ZEN coins from the mainchain, exchange them in sidechain, and send them back to mainchain. The SimpleApp does not add any new logic, it only configures and uses available classes and objects. Chapter 7 of this tutorial offers a detailed introduction to the SDK core functionalities used by the SimpleApp, and it’s a great place to start exploring the code.
The next step to develop a new sidechain application, is to implement new data and logic in a sidechain node. The “Car Registry” example included in the SDK, shows how the basic components can be extended to deliver the needed functionalities. The process is documented in Chapter 8 and Chapter 9, as a step by step guide to build a custom sidechain. When that flow is clear, you’ll be ready to bootstrap and run your fully distributed, decentralized blockchain, supporting your data, logic, and handling ZEN coins!

